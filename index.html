<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Malha estática — rápido</title>
  <link rel="icon" href="data:;base64,=">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html,body,#map{height:100%;margin:0}
    .panel{position:absolute;z-index:1000;left:10px;bottom:10px;background:rgba(255,255,255,.95);padding:8px 10px;border-radius:10px;font:500 12px system-ui,Segoe UI,Roboto,Arial;box-shadow:0 2px 10px rgba(0,0,0,.08);display:flex;gap:8px;align-items:center}
    .btn{border:1px solid #e5e7eb;border-radius:8px;padding:6px 10px;background:#fff;cursor:pointer}
    .muted{color:#6b7280}
  </style>
</head>
<body>
<div id="map"></div>
<div class="panel">
  <button id="btnOSRM" class="btn">Recalcular rotas com OSRM (opcional)</button>
  <button id="btnSave" class="btn" style="display:none">Baixar rotas.geojson</button>
  <span class="muted" id="status"></span>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/shpjs@4.0.4/dist/shp.min.js"></script>

<script>
const RC_ZIPS = ['RC_2.1.zip', 'RC_2.2.zip', 'RC_2.4.zip', 'RC_2.5.zip', 'RC_2.6_2.8.zip', 'RC_2.7.zip'];
const OSRM_URL = 'https://router.project-osrm.org/route/v1/driving/';
const map = L.map('map', { preferCanvas:true }).setView([-22.9,-47.0],7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19,attribution:'&copy; OpenStreetMap'}).addTo(map);

function cor(seed){let h=0;for(let i=0;i<seed.length;i++)h=(h*31+seed.charCodeAt(i))%360;return `hsl(${h},70%,48%)`; }

const group = L.featureGroup().addTo(map);

function drawRotas(gj){
  group.clearLayers();
  L.geoJSON(gj, {
    style: f => ({ color: cor((f.properties&&f.properties.rodovia)||'X'), weight:5, opacity:.9 }),
    onEachFeature: (f, layer) => {
      const p = f.properties||{};
      const txt = `<b>${p.rodovia||'Rodovia'}</b>` + (p.kmInicial!=null&&p.kmFinal!=null ? `<br>Km ${p.kmInicial} – ${p.kmFinal}` : '');
      layer.bindPopup(txt);
      group.addLayer(layer);
    }
  });
  const b = group.getBounds(); if (b.isValid()) map.fitBounds(b.pad(0.05));
}

(async function init(){
  // 1) Rotas estáticas
  let rotas = null;
  try { const r = await fetch('rotas.geojson',{cache:'no-store'}); if(r.ok) rotas = await r.json(); } catch(e) {}
  if (rotas) drawRotas(rotas);

  // 2) Fundo: rc_simplificado.geojson; se vazio, cai para shapefiles RC_*.zip (se existirem na pasta)
  try {
    const rc = await (await fetch('rc_simplificado.geojson',{cache:'no-store'})).json();
    if (rc && rc.features && rc.features.length>0) {
      L.geoJSON(rc, { style:{ color:'#4B5563',weight:2,opacity:.6,fillColor:'#9CA3AF',fillOpacity:.15 }, interactive:false }).addTo(map);
    } else if (RC_ZIPS.length) {
      for (const z of RC_ZIPS) {
        try {
          const head = await fetch(z,{method:'HEAD'});
          if (!head.ok) continue;
          const ab = await (await fetch(z,{cache:'no-store'})).arrayBuffer();
          const gj = await shp.parseZip(ab);
          L.geoJSON(gj, { style:{ color:'#9CA3AF',weight:1,opacity:.4,fillOpacity:0 }, interactive:false }).addTo(map);
        } catch(e) { console.warn('[RC] falhou', z, e); }
      }
    }
  } catch(e) { console.warn('RC simplificado indisponível', e); }

  if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js').catch(console.error); }
})();

// ---- Botão opcional: recalcular com OSRM e permitir baixar o novo rotas.geojson ----
const btn = document.getElementById('btnOSRM');
const btnSave = document.getElementById('btnSave');
const statusEl = document.getElementById('status');

btn.addEventListener('click', async () => {
  btn.disabled = true; statusEl.textContent = 'Roteando via OSRM...';
  try {
    const rotas = await (await fetch('rotas.geojson',{cache:'no-store'})).json();
    const feats = rotas.features||[];
    let done=0;
    for (const f of feats) {
      const g=f.geometry||{};
      if (g.type!=='LineString'||!g.coordinates||g.coordinates.length<2) { done++; continue; }
      const a=g.coordinates[0], b=g.coordinates[g.coordinates.length-1];
      const a_lat=a[1], a_lng=a[0], b_lat=b[1], b_lng=b[0];
      if (!(Math.abs(a_lat)<=85 && Math.abs(b_lat)<=85 && Math.abs(a_lng)<=180 && Math.abs(b_lng)<=180)) { done++; continue; }
      const url = `${OSRM_URL}${a_lng},${a_lat};${b_lng},${b_lat}?overview=full&geometries=geojson`;
      try {
        const r = await fetch(url);
        if (r.ok) {
          const j = await r.json();
          const coords = j?.routes?.[0]?.geometry?.coordinates;
          if (coords && coords.length>1) {
            g.coordinates = coords; // [lon,lat]
          }
        }
      } catch(e) {}
      done++; statusEl.textContent = `Roteando via OSRM... (${done}/${feats.length})`;
    }
    drawRotas(rotas);
    btnSave.style.display = 'inline-block';
    btnSave.onclick = () => {
      const blob = new Blob([JSON.stringify(rotas)], {type:'application/geo+json'});
      const url = URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='rotas.geojson'; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    };
    statusEl.textContent = 'Rotas atualizadas. Clique em "Baixar rotas.geojson" para salvar.';
  } finally { btn.disabled = false; }
});
</script>
</body>
</html>
