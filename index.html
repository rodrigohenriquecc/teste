<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Malha Rodoviária (meta.csv) — Rotas OSRM</title>
  <link rel="icon" href="data:;base64,=">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #map { height: 100vh; }
    .leaflet-control-attribution { font-size: 11px; }
    .rod-label.stacked {
      font: 700 12px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #111;
      text-shadow: 0 0 2px rgba(255,255,255,.9), 0 0 6px rgba(255,255,255,.9);
      white-space: nowrap;
      pointer-events: none;
    }
    .legend {
      position: absolute; z-index: 1000; bottom: 12px; left: 10px;
      background: rgba(255,255,255,.9); border-radius: 10px; padding: 8px 12px;
      font: 500 12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 2px 10px rgba(0,0,0,.08);
      max-width: 360px;
    }
    .legend label { display: flex; align-items: center; gap: 8px; cursor: pointer; }
    .status {
      position: absolute; z-index: 1000; top: 10px; left: 10px;
      background: rgba(255,255,255,.9); border-radius: 10px; padding: 8px 12px;
      font: 500 13px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 2px 10px rgba(0,0,0,.08);
      display: none;
    }
    .status .bar { height: 6px; background: #e5e7eb; border-radius: 999px; overflow: hidden; margin-top: 6px; }
    .status .bar > div { height: 100%; width: 0%; background: #4f46e5; transition: width .2s linear; }
    .status code { background: #f2f2f2; padding: 1px 4px; border-radius: 4px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="legend">
    <label>
      <input type="checkbox" id="toggleRoute" checked>
      Usar rota real (OSRM). Desmarque para linhas retas.
    </label>
  </div>

  <div class="status" id="status">
    <div><strong>Roteando</strong> trechos via <code>OSRM</code>: <span id="prog">0/0</span></div>
    <div class="bar"><div id="bar"></div></div>
    <div id="msg" style="margin-top:6px;color:#6b7280"></div>
  </div>

  <!-- PapaParse (sem integrity; com fallback) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    (function ensurePapa() {
      if (typeof Papa !== 'undefined') return;
      var s = document.createElement('script');
      s.src = 'https://unpkg.com/papaparse@5.4.1/papaparse.min.js';
      document.head.appendChild(s);
    })();
  </script>
  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- ===== MALHA RODOVIÁRIA — OSRM ===== -->
  <script>
  (function() {
    const USE_CACHE   = true;   // cache no localStorage para rotas
    const OSRM_URL    = 'https://router.project-osrm.org/route/v1/driving/';
    const CONCURRENCY = 3;      // nº de requisições simultâneas ao OSRM

    const statusBox = document.getElementById('status');
    const progSpan  = document.getElementById('prog');
    const barDiv    = document.getElementById('bar');
    const msgDiv    = document.getElementById('msg');
    const chkRoute  = document.getElementById('toggleRoute');

    function setStatus(done, total, msg) {
      if (total <= 0 || done >= total) { statusBox.style.display = 'none'; return; }
      statusBox.style.display = 'block';
      progSpan.textContent = done + '/' + total;
      barDiv.style.width = ((done/total)*100).toFixed(1) + '%';
      msgDiv.textContent = msg || '';
    }

    function waitForDeps() {
      return new Promise((resolve, reject) => {
        const t0 = Date.now();
        (function poll() {
          if (typeof Papa !== 'undefined' && Papa.parse && typeof L !== 'undefined') return resolve();
          if (Date.now() - t0 > 15000) return reject(new Error('Dependências não carregaram (Papa/Leaflet).'));
          setTimeout(poll, 100);
        })();
      });
    }

    function sanitizarCSV(csvText) {
      const lines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
      if (!lines.length) return csvText;
      const header = lines[0];
      const fixed = [header];
      for (let i = 1; i < lines.length; i++) {
        let s = lines[i].trim();
        if (!s) continue;
        if (s.startsWith('"') && s.endsWith('"')) s = s.slice(1, -1).replace(/""/g, '"');
        fixed.push(s);
      }
      return fixed.join('\n');
    }
    function parseDecComma(str) {
      if (str == null) return NaN;
      const s = String(str).trim().replace(/\./g, '').replace(',', '.');
      const n = parseFloat(s);
      return Number.isFinite(n) ? n : NaN;
    }
    function corHslDaString(seed) {
      let h = 0;
      for (let i = 0; i < seed.length; i++) h = (h * 31 + seed.charCodeAt(i)) % 360;
      return `hsl(${h}, 70%, 48%)`;
    }

    function cacheKey(lat1,lng1,lat2,lng2) {
      // arredonda para reduzir chaves distintas quase iguais
      return `osrm:v1:driving:${lat1.toFixed(5)},${lng1.toFixed(5)}|${lat2.toFixed(5)},${lng2.toFixed(5)}`;
    }
    async function osrmRoute(lat1, lng1, lat2, lng2) {
      const key = cacheKey(lat1,lng1,lat2,lng2);
      if (USE_CACHE) {
        const got = localStorage.getItem(key);
        if (got) try { return JSON.parse(got); } catch {}
      }
      const url = `${OSRM_URL}${lng1},${lat1};${lng2},${lat2}?overview=full&geometries=geojson`;
      const r = await fetch(url);
      if (!r.ok) throw new Error('OSRM HTTP ' + r.status);
      const json = await r.json();
      const coords = json?.routes?.[0]?.geometry?.coordinates || null; // [lon,lat]
      if (!coords || !coords.length) throw new Error('OSRM sem geometria');
      const latlngs = coords.map(c => [c[1], c[0]]);
      if (USE_CACHE) localStorage.setItem(key, JSON.stringify(latlngs));
      return latlngs;
    }

    async function carregarMeta() {
      const resp = await fetch('./meta.csv', { cache: 'no-store' });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      let csvText = await resp.text();
      csvText = sanitizarCSV(csvText);

      return new Promise((resolve) => {
        Papa.parse(csvText, {
          header: true, skipEmptyLines: true,
          complete: ({ data }) => {
            const trechosPorRodovia = {};
            data.forEach(row => {
              const rodovia = (row['Rodovia'] || '').toString().trim();
              if (!rodovia) return;
              const kmInicial = parseDecComma(row['Km Inicial']);
              const kmFinal   = parseDecComma(row['Km Final']);
              const ci = (row['Lat e Long km Inicial'] || '').split(',');
              const cf = (row['Lat e Long km final']   || '').split(',');
              const latI = parseFloat((ci[0] || '').trim());
              const lngI = parseFloat((ci[1] || '').trim());
              const latF = parseFloat((cf[0] || '').trim());
              const lngF = parseFloat((cf[1] || '').trim());
              if (![latI,lngI,latF,lngF].every(Number.isFinite)) return;
              (trechosPorRodovia[rodovia] ||= []).push({
                rodovia, kmInicial, kmFinal,
                coordInicial: [latI, lngI],
                coordFinal:   [latF, lngF]
              });
            });
            Object.values(trechosPorRodovia).forEach(lista => lista.sort((a,b) => (a.kmInicial ?? 0) - (b.kmInicial ?? 0)));
            resolve(trechosPorRodovia);
          }
        });
      });
    }

    function desenhar(trechosPorRodovia) {
      const mapa = L.map('map', { preferCanvas: true }).setView([-23.5, -47.5], 8);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(mapa);

      if (!mapa.getPane('malhaPane')) { mapa.createPane('malhaPane'); mapa.getPane('malhaPane').style.zIndex = 450; }

      const bounds = L.latLngBounds();
      const overlayGroup = L.layerGroup([], { pane: 'malhaPane' }).addTo(mapa);
      const labelsGroup  = L.layerGroup([], { pane: 'malhaPane' }).addTo(mapa);

      const useRouted = () => !chkRoute || chkRoute.checked;

      // acumuladores para labels por rodovia
      const rodStats = {}; // rodovia -> {sumLat,sumLng,count,color}

      // criar fila de jobs
      const jobs = []; let total = 0, done = 0;
      Object.entries(trechosPorRodovia).forEach(([rodovia, trechos]) => {
        const color = corHslDaString(rodovia);
        rodStats[rodovia] = { sumLat: 0, sumLng: 0, count: 0, color };

        trechos.forEach((t, idx) => {
          total++;
          jobs.push(async () => {
            let latlngs;
            if (useRouted()) {
              try { latlngs = await osrmRoute(t.coordInicial[0], t.coordInicial[1], t.coordFinal[0], t.coordFinal[1]); }
              catch (e) { console.warn('OSRM falhou, usando reta:', e); }
            }
            if (!latlngs) latlngs = [t.coordInicial, t.coordFinal];

            const linha = L.polyline(latlngs, { color, weight: 5, opacity: 0.9, lineJoin: 'round' })
              .bindPopup(`<b>${rodovia}</b><br>${
                Number.isFinite(t.kmInicial)&&Number.isFinite(t.kmFinal)
                ? `Km ${t.kmInicial.toFixed(3)} – ${t.kmFinal.toFixed(3)}`
                : `Trecho ${idx+1}`
              }`);
            overlayGroup.addLayer(linha);
            latlngs.forEach(ll => bounds.extend(ll));

            const mid = latlngs[Math.floor(latlngs.length/2)];
            rodStats[rodovia].sumLat += mid[0];
            rodStats[rodovia].sumLng += mid[1];
            rodStats[rodovia].count  += 1;

            done++; setStatus(done, total, 'Trecho ' + done + ' concluído');
          });
        });
      });

      async function runQueue(tasks, concurrency) {
        let i = 0; const runners = [];
        setStatus(0, total, 'Iniciando...');
        for (let k = 0; k < Math.min(concurrency, tasks.length); k++) {
          runners.push((async function run() {
            while (i < tasks.length) { const j = i++; await tasks[j](); }
          })());
        }
        await Promise.all(runners);
      }

      runQueue(jobs, CONCURRENCY).then(() => {
        // cria labels após todos os trechos
        Object.entries(rodStats).forEach(([rodovia, st]) => {
          if (st.count > 0) {
            const centro = [st.sumLat / st.count, st.sumLng / st.count];
            labelsGroup.addLayer(L.marker(centro, { interactive: false, pane: 'malhaPane',
              icon: L.divIcon({ className: 'rod-label stacked', html: rodovia }) }));
          }
        });

        setStatus(total, total);
        if (bounds.isValid()) mapa.fitBounds(bounds.pad(0.05));
      });

      if (chkRoute) chkRoute.addEventListener('change', () => location.reload());

      L.control.layers(null, { 'Malha Rodoviária (meta.csv)': L.layerGroup([overlayGroup, labelsGroup]) }, { collapsed: true }).addTo(mapa);
    }

    (async function main() {
      try {
        await waitForDeps();
        const trechos = await carregarMeta();
        desenhar(trechos);
      } catch (e) {
        alert('Erro ao carregar/desenhar a malha. Veja o console.');
        console.error(e);
      }
    })();
  })();
  </script>
  <!-- ===== FIM MALHA RODOVIÁRIA — OSRM ===== -->
</body>
</html>
