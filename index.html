<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Malha — OSRM + RC</title>
  <link rel="icon" href="data:;base64,=">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #map { height: 100vh; }
    .rod-label.stacked {
      font: 700 12px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #111; text-shadow: 0 0 2px rgba(255,255,255,.9), 0 0 6px rgba(255,255,255,.9);
      white-space: nowrap; pointer-events: none;
    }
    .panel {
      position:absolute; z-index:1000; bottom:12px; left:10px;
      background:rgba(255,255,255,.9); border-radius:10px; padding:8px 12px;
      font:500 12px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      box-shadow:0 2px 10px rgba(0,0,0,.08);
    }
    .status {
      position:absolute; z-index:1000; top:10px; left:10px;
      background:rgba(255,255,255,.9); border-radius:10px; padding:8px 12px;
      font:500 13px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      box-shadow:0 2px 10px rgba(0,0,0,.08); display:none;
    }
    .status .bar { height:6px; background:#e5e7eb; border-radius:999px; overflow:hidden; margin-top:6px; }
    .status .bar > div { height:100%; width:0%; background:#4f46e5; transition:width .2s linear; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
      <input type="checkbox" id="toggleRoute" checked>
      Usar rota real (OSRM)
    </label>
  </div>

  <div class="status" id="status">
    <div><strong>Roteando</strong> trechos via OSRM: <span id="prog">0/0</span></div>
    <div class="bar"><div id="bar"></div></div>
    <div id="msg" style="margin-top:6px;color:#6b7280"></div>
  </div>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>if(typeof Papa==='undefined'){var s=document.createElement('script');s.src='https://unpkg.com/papaparse@5.4.1/papaparse.min.js';document.head.appendChild(s);}</script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/shpjs@4.0.4/dist/shp.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
  (function(){
    // ==== LISTA DOS RC (coloque aqui os que você tiver na pasta) ====
    const RC_LIST = [
      { name: 'RC_2.1', path: './RC_2.1.zip' },
      { name: 'RC_2.2', path: './RC_2.2.zip' },
      { name: 'RC_2.4', path: './RC_2.4.zip' },
      { name: 'RC_2.5', path: './RC_2.5.zip' },
      { name: 'RC_2.6_2.8', path: './RC_2.6_2.8.zip' },
      { name: 'RC_2.7', path: './RC_2.7.zip' }
    ];

    const TOL = 0.0001; // simplificação fixa
    const USE_CACHE = true;
    const OSRM_URL  = 'https://router.project-osrm.org/route/v1/driving/';
    const CONCURRENCY = 3;

    // ==== UI ====
    const statusBox = document.getElementById('status');
    const progSpan  = document.getElementById('prog');
    const barDiv    = document.getElementById('bar');
    const msgDiv    = document.getElementById('msg');
    const chkRoute  = document.getElementById('toggleRoute');

    function setStatus(done, total, msg) {
      if (total <= 0 || done >= total) { statusBox.style.display = 'none'; return; }
      statusBox.style.display = 'block';
      progSpan.textContent = done + '/' + total;
      barDiv.style.width   = ((done/total)*100).toFixed(1) + '%';
      msgDiv.textContent   = msg || '';
    }

    function cor(seed) {
      let h = 0;
      for (let i = 0; i < seed.length; i++) h = (h * 31 + seed.charCodeAt(i)) % 360;
      return 'hsl(' + h + ',70%,48%)';
    }

    // --------- PARSE NÚMEROS ROBUSTO (pt-BR e en-US) ---------
    function toNumberBR(val) {
      if (val == null) return NaN;
      let s = String(val).trim();
      s = s.replace(/[^\d,\.\-+]/g, '');       // mantém dígitos, sinais e separadores
      const hasComma = s.includes(',');
      const hasDot   = s.includes('.');
      if (hasComma && hasDot) {
        // define decimal pelo separador que aparece por último
        if (s.lastIndexOf(',') > s.lastIndexOf('.')) {
          s = s.replace(/\./g, '').replace(',', '.');
        } else {
          s = s.replace(/,/g, '');
        }
      } else if (hasComma) {
        s = s.replace(/\./g, '').replace(',', '.');
      } // se só tem ponto ou nenhum, mantém
      let n = parseFloat(s);
      if (!Number.isFinite(n)) return NaN;
      // normaliza micrograus (ex: -47570500 -> -47.5705)
      if (Math.abs(n) > 180) {
        if (Math.abs(n) <= 180000000) n = n / 1e6;
        else if (Math.abs(n) <= 1800000) n = n / 1e4;
      }
      return n;
    }

    function sanitCSV(s) {
      const lines = s.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
      if (!lines.length) return s;
      const out = [lines[0]];
      for (let i = 1; i < lines.length; i++) {
        let L = lines[i].trim();
        if (!L) continue;
        if (L.startsWith('"') && L.endsWith('"')) L = L.slice(1, -1).replace(/""/g, '"');
        out.push(L);
      }
      return out.join('\n');
    }

    function pick(row, names) {
      for (const n of names) {
        if (Object.prototype.hasOwnProperty.call(row, n) && row[n] != null && String(row[n]).trim() !== '') return row[n];
      }
      return null;
    }

    // Extrai [lat,lng] de string em vários formatos
    function parseCoord(raw) {
      if (!raw) return null;
      let s = String(raw).trim();
      s = s.replace(/[()\[\]]/g,' ').replace(/Lat\.?|Latitude|Long\.?|Longitude|Lon\.?/gi,' ').replace(/[;|]/g,',');
      const m = s.match(/[-+]?\d+(?:[\.,]\d+)?/g);
      if (!m || m.length < 2) return null;
      let lat = toNumberBR(m[0]);
      let lng = toNumberBR(m[1]);
      // se invertido (Brasil: |lat|<40, |lng|>40), tenta corrigir
      if (!(Math.abs(lat) <= 90 && Math.abs(lng) <= 180) && (Math.abs(lng) <= 90 && Math.abs(lat) <= 180)) {
        const tmp = lat; lat = lng; lng = tmp;
      }
      // última validação
      if (!(Number.isFinite(lat) && Number.isFinite(lng) && Math.abs(lat) <= 90 && Math.abs(lng) <= 180)) return null;
      return [lat, lng];
    }

    function cacheKey(a,b,c,d) {
      return 'osrm:' + a.toFixed(6) + ',' + b.toFixed(6) + '|' + c.toFixed(6) + ',' + d.toFixed(6);
    }

    async function osrm(a,b,c,d) {
      // OSRM requer lat dentro de ~[-85,85]
      if (!(Math.abs(a) <= 85 && Math.abs(c) <= 85 && Math.abs(b) <= 180 && Math.abs(d) <= 180)) {
        throw new Error('coord fora de faixa OSRM');
      }
      const k = cacheKey(a,b,c,d);
      if (USE_CACHE) {
        const got = localStorage.getItem(k);
        if (got) { try { return JSON.parse(got); } catch (e) {} }
      }
      const url = OSRM_URL + b + ',' + a + ';' + d + ',' + c + '?overview=full&geometries=geojson';
      const r = await fetch(url);
      if (!r.ok) throw new Error('OSRM ' + r.status);
      const j = await r.json();
      if (!(j && j.routes && j.routes[0] && j.routes[0].geometry && j.routes[0].geometry.coordinates)) {
        throw new Error('OSRM sem geometria');
      }
      const latlngs = j.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
      if (USE_CACHE) localStorage.setItem(k, JSON.stringify(latlngs));
      return latlngs;
    }

    async function carregarMeta() {
      const r = await fetch('./meta.csv', { cache: 'no-store' });
      if (!r.ok) throw new Error('HTTP ' + r.status);
      let t = await r.text();
      t = sanitCSV(t);
      return new Promise((resolve) => {
        Papa.parse(t, {
          header: true,
          skipEmptyLines: true,
          delimiter: "",
          complete: ({ data }) => {
            const map = {};
            let totalLinhas = 0, totalValidas = 0;
            data.forEach(row => {
              totalLinhas++;
              const rod = (pick(row, ['Rodovia','rodovia']) || '').toString().trim();
              if (!rod) return;
              const ki = toNumberBR(pick(row, ['Km Inicial','km inicial','Km inicial','KmInicial','KM Inicial']));
              const kf = toNumberBR(pick(row, ['Km Final','km final','Km final','KmFinal','KM Final']));
              const sI = pick(row, ['Lat e Long km Inicial','Lat e Long km inicial','Lat e Long km INICIAL','Lat e Long km inicial ']);
              const sF = pick(row, ['Lat e Long km Final','Lat e Long km final','Lat e Long km FINAL','Lat e Long km final ']);
              const ci = parseCoord(sI);
              const cf = parseCoord(sF);
              if (!ci || !cf) { console.warn('[META] linha ignorada por coordenadas inválidas:', row); return; }
              (map[rod] || (map[rod] = [])).push({
                rodovia: rod, kmInicial: ki, kmFinal: kf, coordInicial: ci, coordFinal: cf
              });
              totalValidas++;
            });
            console.log('[META] linhas:', totalLinhas, '| trechos válidos:', totalValidas, '| rodovias:', Object.keys(map).length);
            Object.values(map).forEach(lst => lst.sort((a,b) => (a.kmInicial || 0) - (b.kmInicial || 0)));
            resolve(map);
          }
        });
      });
    }

    function desenhar(trechos) {
      const m = L.map('map', { preferCanvas: true }).setView([-22.9, -47.0], 7);
      window.mapa = m;
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(m);
      if (!m.getPane('rcPane'))    { m.createPane('rcPane');    m.getPane('rcPane').style.zIndex = 300; }
      if (!m.getPane('malhaPane')) { m.createPane('malhaPane'); m.getPane('malhaPane').style.zIndex = 450; }

      const bounds  = L.latLngBounds();
      const overlay = L.layerGroup([], { pane: 'malhaPane' }).addTo(m);
      const labels  = L.layerGroup([], { pane: 'malhaPane' }).addTo(m);

      const useRouted = () => !chkRoute || chkRoute.checked;

      const stats = {}, jobs = [];
      let total = 0, done = 0;

      const entries = Object.entries(trechos);
      if (!entries.length) {
        console.warn('[META] Nenhum trecho foi interpretado. Verifique cabeçalhos/formatos no meta.csv.');
      }
      entries.forEach(([rod, lst]) => {
        const color = cor(rod);
        stats[rod] = { lat: 0, lng: 0, c: 0 };
        lst.forEach((t, idx) => {
          total++;
          jobs.push(async () => {
            let latlngs = null;
            if (useRouted()) {
              try { latlngs = await osrm(t.coordInicial[0], t.coordInicial[1], t.coordFinal[0], t.coordFinal[1]); }
              catch (e) { console.warn('OSRM falhou, reta:', e); }
            }
            if (!latlngs) latlngs = [t.coordInicial, t.coordFinal];
            // filtra qualquer ponto fora de faixa
            latlngs = latlngs.filter(ll => Array.isArray(ll) && ll.length===2 && ll.every(Number.isFinite) && Math.abs(ll[0])<=90 && Math.abs(ll[1])<=180);
            if (latlngs.length < 2) { console.warn('Trecho inválido (poucos pontos):', t); done++; setStatus(done, total); return; }
            const line = L.polyline(latlngs, { color, weight: 5, opacity: 0.9, lineJoin: 'round' })
              .bindPopup('<b>' + rod + '</b><br>' + (
                (Number.isFinite(t.kmInicial) && Number.isFinite(t.kmFinal))
                  ? ('Km ' + t.kmInicial.toFixed(3) + ' – ' + t.kmFinal.toFixed(3))
                  : ('Trecho ' + (idx + 1))
              ));
            overlay.addLayer(line);
            latlngs.forEach(ll => bounds.extend(ll));
            const mid = latlngs[Math.floor(latlngs.length/2)];
            stats[rod].lat += mid[0]; stats[rod].lng += mid[1]; stats[rod].c++;
            done++; setStatus(done, total, 'Trecho ' + done + ' concluído');
          });
        });
      });

      async function runQueue(tasks, concurrency) {
        let i = 0;
        const runners = [];
        setStatus(0, total, 'Iniciando...');
        for (let k = 0; k < Math.min(concurrency, tasks.length); k++) {
          runners.push((async function run() {
            while (i < tasks.length) {
              const j = i++; await tasks[j]();
            }
          })());
        }
        await Promise.all(runners);
      }

      runQueue(jobs, CONCURRENCY).then(() => {
        Object.entries(stats).forEach(([rod, st]) => {
          if (st.c > 0) {
            const centro = [st.lat / st.c, st.lng / st.c];
            labels.addLayer(L.marker(centro, {
              interactive: false, pane: 'malhaPane',
              icon: L.divIcon({ className: 'rod-label stacked', html: rod })
            }));
          }
        });
        setStatus(total, total, '');
        if (bounds.isValid()) m.fitBounds(bounds.pad(0.05));
      });

      chkRoute && chkRoute.addEventListener('change', () => location.reload());
    }

    async function addRC() {
      const m = window.mapa; if (!m) return;
      if (!m.getPane('rcPane')) { m.createPane('rcPane'); m.getPane('rcPane').style.zIndex = 300; }
      for (const item of RC_LIST) {
        if (!item || !item.path) continue;
        try {
          const resp = await fetch(item.path, { cache: 'no-store' });
          if (!resp.ok) throw new Error('HTTP ' + resp.status);
          const ab = await resp.arrayBuffer();
          const gj = await shp.parseZip(ab);
          const simp = turf.simplify(gj, { tolerance: TOL, highQuality: false, mutate: false });
          L.geoJSON(simp, {
            pane: 'rcPane',
            style: { color: '#4B5563', weight: 2, opacity: 0.6, fillColor: '#9CA3AF', fillOpacity: 0.15 },
            interactive: false
          }).addTo(m);
        } catch (e) {
          console.error('[RC] falhou', item.name, e);
        }
      }
    }

    (async function main(){
      try {
        const trechos = await carregarMeta();
        desenhar(trechos);
        await addRC();
      } catch (e) {
        alert('Falha ao iniciar (veja console).'); console.error(e);
      }
    })();
  })();
  </script>
</body>
</html>
